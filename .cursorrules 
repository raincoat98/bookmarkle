# React 프로젝트 Cursor IDE 규칙

## 프로젝트 개요
- React 18+ 기반 프로젝트
- TypeScript 사용 필수
- 함수형 컴포넌트와 Hooks 사용

## 커밋 메시지 규칙

### 형식
```
<타입>(<범위>): <제목>

<본문>

Jira: <이슈키>
```

### 커밋 타입
- `feat`: 새로운 기능 (컴포넌트, 페이지, 기능)
- `fix`: 버그 수정
- `style`: UI/UX 스타일 변경 (CSS, 디자인)
- `refactor`: 코드 리팩토링
- `perf`: 성능 최적화
- `test`: 테스트 추가/수정
- `docs`: 문서 수정
- `chore`: 의존성 업데이트, 설정 변경
- `build`: 빌드 설정 변경

### 범위 예시
- `components`: 컴포넌트 관련
- `pages`: 페이지 관련
- `hooks`: 커스텀 훅
- `utils`: 유틸리티 함수
- `api`: API 통신
- `store`: 상태 관리 (Redux, Zustand 등)
- `router`: 라우팅
- `styles`: 스타일링

### 커밋 예시 (Jira 연동)
```
feat(components): Button 컴포넌트에 loading 상태 추가

로딩 중일 때 스피너를 표시하고 클릭을 비활성화합니다.
사용자 경험 개선을 위해 추가했습니다.

Jira: PROJ-123
```

```
fix(hooks): useDebounce 훅의 메모리 누수 문제 해결

컴포넌트 언마운트 시 타이머를 정리하도록 수정했습니다.

Jira: PROJ-456
```

### Jira 이슈 참조 규칙
- 푸터에 `Jira: 이슈키` 형식으로 작성
- 여러 이슈 관련 시: `Jira: PROJ-123, PROJ-456`
- 브랜치명에도 Jira 이슈 포함

## React 코드 작성 규칙

### 컴포넌트 구조
```typescript
// 1. Import 순서
import React, { useState, useEffect } from 'react'; // React 관련
import { useNavigate } from 'react-router-dom'; // 외부 라이브러리
import { Button } from '@/components/ui'; // 내부 컴포넌트
import { fetchUserData } from '@/api/user'; // API/유틸리티
import { useAuthStore } from '@/store/auth'; // 상태 관리
import styles from './UserProfile.module.css'; // 스타일
import type { User } from '@/types'; // 타입

// 2. 타입 정의
interface UserProfileProps {
  userId: string;
  onUpdate?: (user: User) => void;
}

// 3. 컴포넌트 정의
export const UserProfile: React.FC<UserProfileProps> = ({ 
  userId, 
  onUpdate 
}) => {
  // 4. Hooks (useState, useEffect, 커스텀 훅 순서)
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(false);
  const navigate = useNavigate();
  const { isAuthenticated } = useAuthStore();

  useEffect(() => {
    loadUser();
  }, [userId]);

  // 5. 이벤트 핸들러
  const handleUpdate = async () => {
    // 로직
  };

  // 6. 렌더 로직
  if (loading) return <div>Loading...</div>;
  if (!user) return <div>User not found</div>;

  // 7. JSX 반환
  return (
    <div className={styles.container}>
      {/* 컴포넌트 내용 */}
    </div>
  );
};
```

### 네이밍 규칙
- **컴포넌트**: PascalCase (예: `UserProfile`, `LoginForm`)
- **컴포넌트 파일**: PascalCase.tsx (예: `UserProfile.tsx`)
- **훅**: use로 시작하는 camelCase (예: `useAuth`, `useFetch`)
- **Props 타입**: 컴포넌트명 + Props (예: `UserProfileProps`)
- **이벤트 핸들러**: handle로 시작 (예: `handleClick`, `handleSubmit`)
- **Boolean 변수**: is, has, should로 시작 (예: `isLoading`, `hasError`)
- **상수**: UPPER_SNAKE_CASE (예: `API_BASE_URL`, `MAX_RETRY_COUNT`)

### 컴포넌트 작성 원칙

#### 1. Props는 구조 분해 할당으로 받기
```typescript
// ✅ Good
const Button: React.FC<ButtonProps> = ({ text, onClick, disabled = false }) => {
  return <button onClick={onClick} disabled={disabled}>{text}</button>;
};

// ❌ Bad
const Button: React.FC<ButtonProps> = (props) => {
  return <button onClick={props.onClick}>{props.text}</button>;
};
```

#### 2. 조건부 렌더링
```typescript
// ✅ Good - Early return
if (loading) return <Spinner />;
if (error) return <ErrorMessage error={error} />;

// ✅ Good - 삼항 연산자 (간단한 경우)
{isLoggedIn ? <Dashboard /> : <LoginForm />}

// ✅ Good - && 연산자
{showModal && <Modal />}

// ❌ Bad - 중첩된 삼항 연산자
{isLoggedIn ? (hasPermission ? <AdminPanel /> : <UserPanel />) : <Login />}
```

#### 3. 컴포넌트 분리
- 100줄 이상이면 분리 검토
- 재사용 가능한 부분은 별도 컴포넌트로
- 복잡한 로직은 커스텀 훅으로 추출

```typescript
// ✅ Good
const UserList = () => {
  const { users, loading, error } = useUsers();
  
  if (loading) return <LoadingSpinner />;
  if (error) return <ErrorMessage error={error} />;
  
  return (
    <div>
      {users.map(user => (
        <UserCard key={user.id} user={user} />
      ))}
    </div>
  );
};
```

### Hooks 사용 규칙

#### 1. useState
```typescript
// ✅ Good - 관련 상태는 객체로 그룹화
const [formData, setFormData] = useState({
  email: '',
  password: '',
  rememberMe: false
});

// ✅ Good - 복잡한 상태는 useReducer 고려
const [state, dispatch] = useReducer(reducer, initialState);

// ❌ Bad - 너무 많은 개별 useState
const [email, setEmail] = useState('');
const [password, setPassword] = useState('');
const [name, setName] = useState('');
// ... 10개 이상
```

#### 2. useEffect
```typescript
// ✅ Good - 의존성 배열 정확히 명시
useEffect(() => {
  fetchData(userId);
}, [userId]);

// ✅ Good - cleanup 함수 사용
useEffect(() => {
  const timer = setTimeout(() => {
    // 로직
  }, 1000);
  
  return () => clearTimeout(timer);
}, []);

// ❌ Bad - 빈 의존성 배열로 경고 무시
useEffect(() => {
  // userId를 사용하지만 의존성에 없음
  fetchData(userId);
}, []); // eslint-disable-line
```

#### 3. 커스텀 훅 작성
```typescript
// ✅ Good
export const useAuth = () => {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    checkAuth();
  }, []);

  const login = async (credentials: Credentials) => {
    // 로그인 로직
  };

  const logout = () => {
    // 로그아웃 로직
  };

  return { user, loading, login, logout };
};
```

### 성능 최적화

#### 1. useMemo, useCallback 사용
```typescript
// ✅ Good - 비용이 큰 계산은 메모이제이션
const sortedUsers = useMemo(() => {
  return users.sort((a, b) => a.name.localeCompare(b.name));
}, [users]);

// ✅ Good - 콜백 함수 메모이제이션
const handleClick = useCallback(() => {
  onItemClick(item.id);
}, [item.id, onItemClick]);
```

#### 2. React.memo 사용
```typescript
// ✅ Good - props가 자주 변경되지 않는 컴포넌트
export const ExpensiveComponent = React.memo<ExpensiveComponentProps>(
  ({ data }) => {
    return <div>{/* 복잡한 렌더링 */}</div>;
  }
);
```

#### 3. 코드 스플리팅
```typescript
// ✅ Good - lazy loading
const Dashboard = lazy(() => import('@/pages/Dashboard'));
const Settings = lazy(() => import('@/pages/Settings'));

<Suspense fallback={<LoadingSpinner />}>
  <Routes>
    <Route path="/dashboard" element={<Dashboard />} />
    <Route path="/settings" element={<Settings />} />
  </Routes>
</Suspense>
```

### 스타일링 규칙

#### CSS Modules 사용 시
```typescript
// ✅ Good
import styles from './Button.module.css';

<button className={styles.primary}>Click</button>
<div className={`${styles.card} ${isActive ? styles.active : ''}`}>
```

#### Tailwind CSS 사용 시
```typescript
// ✅ Good - 조건부 클래스
<button 
  className={`
    px-4 py-2 rounded
    ${variant === 'primary' ? 'bg-blue-500' : 'bg-gray-500'}
    ${disabled ? 'opacity-50 cursor-not-allowed' : 'hover:bg-blue-600'}
  `}
>
```

### 에러 처리

```typescript
// ✅ Good - Error Boundary 사용
class ErrorBoundary extends React.Component<Props, State> {
  static getDerivedStateFromError(error: Error) {
    return { hasError: true };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error('Error caught:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return <ErrorFallback />;
    }
    return this.props.children;
  }
}

// ✅ Good - try-catch 사용
const fetchData = async () => {
  try {
    setLoading(true);
    const data = await api.getData();
    setData(data);
  } catch (error) {
    setError(error instanceof Error ? error.message : 'Unknown error');
  } finally {
    setLoading(false);
  }
};
```

### 타입스크립트 규칙

```typescript
// ✅ Good - 명확한 타입 정의
interface User {
  id: string;
  name: string;
  email: string;
  role: 'admin' | 'user';
}

// ✅ Good - Props 타입 정의
interface ButtonProps {
  text: string;
  onClick: () => void;
  variant?: 'primary' | 'secondary';
  disabled?: boolean;
}

// ❌ Bad - any 타입 사용
const handleData = (data: any) => {
  // 타입 안정성 상실
};

// ✅ Good - Generic 사용
const useApi = <T,>(url: string) => {
  const [data, setData] = useState<T | null>(null);
  // ...
};
```

## 폴더 구조

```
src/
├── components/          # 재사용 가능한 컴포넌트
│   ├── ui/             # 기본 UI 컴포넌트
│   ├── layout/         # 레이아웃 컴포넌트
│   └── common/         # 공통 컴포넌트
├── pages/              # 페이지 컴포넌트
├── hooks/              # 커스텀 훅
├── utils/              # 유틸리티 함수
├── api/                # API 통신
├── store/              # 상태 관리
├── types/              # 타입 정의
├── constants/          # 상수
├── styles/             # 전역 스타일
└── assets/             # 정적 파일
```

## 테스트 규칙

```typescript
// ✅ Good - React Testing Library 사용
import { render, screen, fireEvent } from '@testing-library/react';

describe('Button Component', () => {
  it('renders with correct text', () => {
    render(<Button text="Click me" onClick={() => {}} />);
    expect(screen.getByText('Click me')).toBeInTheDocument();
  });

  it('calls onClick when clicked', () => {
    const handleClick = jest.fn();
    render(<Button text="Click" onClick={handleClick} />);
    fireEvent.click(screen.getByText('Click'));
    expect(handleClick).toHaveBeenCalledTimes(1);
  });
});
```

## Git 브랜치 전략 (Jira 연동)

### 브랜치 네이밍
- `main`: 프로덕션 배포
- `develop`: 개발 통합
- `feature/PROJ-123-button-loading`: 새 기능 (Jira 이슈키 포함)
- `fix/PROJ-456-debounce-memory-leak`: 버그 수정
- `refactor/PROJ-789-user-component`: 리팩토링
- `hotfix/PROJ-999-payment-error`: 긴급 수정

### 예시
```
feature/PROJ-123-user-authentication
fix/PROJ-456-login-validation-error
refactor/PROJ-789-api-service
hotfix/PROJ-999-payment-gateway-issue
```

### 규칙
- 브랜치명에 Jira 이슈 키 필수 포함
- 이슈 키 다음 하이픈(-)으로 구분하여 설명 추가
- 설명은 kebab-case로 작성

## PR (Pull Request) 규칙

### PR 제목 형식
```
[PROJ-123] feat(components): Button 컴포넌트에 loading 상태 추가
```

### PR 설명 템플릿
```markdown
## Jira 이슈
- [PROJ-123](https://your-domain.atlassian.net/browse/PROJ-123)

## 변경 사항
- Button 컴포넌트에 loading prop 추가
- 로딩 중 스피너 표시 기능 구현
- 로딩 중 클릭 비활성화 처리

## 변경 이유
- 사용자가 버튼 클릭 후 로딩 상태를 명확히 인지할 수 있도록 개선
- 중복 클릭 방지로 불필요한 API 호출 감소

## 테스트 방법
1. 로그인 버튼 클릭
2. API 호출 중 스피너가 표시되는지 확인
3. 로딩 중 버튼 클릭이 비활성화되는지 확인

## 스크린샷 (UI 변경 시)
| Before | After |
|--------|-------|
| [이미지] | [이미지] |

## 영향 범위
- 영향받는 컴포넌트: Button, LoginForm, SignupForm
- Breaking Change: 없음

## 체크리스트
- [ ] Jira 이슈와 연결됨
- [ ] 코드 리뷰 준비 완료
- [ ] 테스트 통과
- [ ] 문서 업데이트 완료
- [ ] 브레이킹 체인지 확인
- [ ] Jira 이슈 상태 업데이트 (In Review)
```

### PR 라벨 규칙
- `feature`: 새 기능
- `bugfix`: 버그 수정
- `hotfix`: 긴급 수정
- `refactor`: 리팩토링
- `performance`: 성능 개선
- `needs-review`: 리뷰 필요
- `approved`: 승인됨
- `blocked`: 차단됨

## 권장 도구

- **Linter**: ESLint (with react, typescript plugins)
- **Formatter**: Prettier
- **Testing**: Vitest, React Testing Library
- **State**: Zustand, Redux Toolkit, Jotai
- **Styling**: Tailwind CSS, CSS Modules, Styled-components
- **Build**: Vite, Create React App
- **Type Check**: TypeScript strict mode
- **Git Hook**: Husky (commit message에 Jira 이슈 자동 검증)
- **CI/CD**: GitHub Actions, GitLab CI (Jira 자동 연동)

## Jira 워크플로우 연동

### 이슈 상태와 브랜치 매핑
- **Todo** → 브랜치 생성 (feature/PROJ-123-...)
- **In Progress** → 개발 중
- **Code Review** → PR 생성 시 자동 전환
- **Done** → PR 머지 후 자동 전환

### Git Commit으로 Jira 이슈 자동 전환
```bash
# 이슈를 In Progress로 전환
git commit -m "feat(auth): 로그인 기능 구현

Jira: PROJ-123 #in-progress"

# 이슈에 작업 시간 기록
git commit -m "fix(api): API 에러 처리 개선

Jira: PROJ-456 #time 1h 30m #comment API 에러 핸들링 개선 완료"

# 이슈를 완료로 전환
git commit -m "feat(dashboard): 대시보드 UI 완성

Jira: PROJ-789 #done"
```

### Smart Commit 명령어
- `#comment <텍스트>`: 이슈에 코멘트 추가
- `#time <시간>`: 작업 시간 기록 (예: 2h 30m, 1d 4h)
- `#in-progress`: 이슈를 In Progress로 전환
- `#done`: 이슈를 Done으로 전환
- `#close`: 이슈 닫기